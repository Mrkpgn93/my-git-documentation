git status

git init

git add <file-name> <file-name2>...

git add .

git commit -m "my message"

git log

git log --oneline

git log --graph --abbrev-commit --decorate --format=format:'%C(bold blue)%h%C(reset) - %C(bold green)(%ar)%C(reset) %C(white)%s%C(reset) %C(dim white)- %an%C(reset)%C(bold yellow)%d%C(reset)' --all

git commit --amend          // Posso tornare indietro soltanto di un passo! viene comodo quando devo modificare il messaggio del commit oppure aggiungere qualcosa che mi ero dimenticato all'interno dello stage

git branch                      // vedo l'elenco dei branch anteponendo il simbolo * su quello in cui mi trovo

git branch <branch-name>        // crea un nuovo branch con il branch-name indicato a partire dall'HEAD corrente

Quando decido di fare switch da un branch all'altro devo sempre vedere se ho lasciato qualcosa all'interno dello stage, mi potrei trovare in 2 casi:
1- tutto quello che ho nello stage non va in conflitto con il branch sul quale voglio switchare, se non committo prima di switchare allora mi trascino con me tutto lo stage
2- parte dello stage va in conflitto con il branch sul quale voglio switchare, in questo caso git mi blocca e mi da solo due alternative:
    2.1- committare tutto quello che c'è nello stage e SOLO DOPO switchare
    2.2- stashare il materiale così da poter switchare liberamente 

git switch <branch-name>        // sposto il puntatore HEAD in corrispondenza dell'ultimo commit del <branch-name>

git commit -a -m <message>		// "git add ." + "git commit" 

git switch -c <branch-name>		// "git branch <branch-name>" + "git switch <branch-name>"

Quando voglio cancellare un branch devo sempre farlo stando su un'altro branch!!!

git branch -d <branch-name>		// cancella un branch (da utilizzare subito dopo un git merge <branch-name>)

git branch -D <branch-name>		// forza la cancellazione di un branch che è rimasto "appeso" xk non è stato mergiato (pericoloso...)

git branch -m <branch-name>     // rinomina il branch corrente con branch-name	

Esitono 3 tipi di merge:
1- Fast Forward Merge -> avviene quando eseguo commit su uno dei due branch senza toccare l'altro
2- Merge Commit -> avviene quando i due branch sono entrambi committati ma la loro unione non determina conflitti (git esegue il commit del merge per noi)
3- Merge Conflicts -> avviene quando i due branch sono entrambi committati e la loro unione determina conflitti (xk ad es. modificano le stesse righe), in questo caso dobbiamo manualmente risolvere il conflitto (tramite editor) e successivamente committare il merge

Molto spesso quando si ha la certezza che un merge genererà conflitti per non compromettere uno dei due branch (sul quale dovrei fare il merge) si preferisce creare prima un nuovo branch di prova
con l'HEAD su uno dei due branch e SOLO dopo su quest'ultimo fare il merge, se tutto va a buon fine solo allora si confluisce su uno dei branch di partenza

git merge <branch-name>         // restituisce un branch unione (intersezione in caso di conflitti) con il branch-name indicato, da notare che il branch-name rimmarrà invariato

git diff        // mostra a video tutti i cambiamenti della cartella di lavoro che non sono stati ancora inseriti nell'area di stage, eseguito il "git add ." non ottengo nessun risultato

git diff head [filename]  // mostra a video tutti i cambiamenti del file system dall'ultimo commit (sia che siano nello stage oppure no), nel caso non ho modificato il progetto (quindi HEAD punta ancora all'ultimo commit) non ottengo nessun risultato

git diff --staged [filename]  <--> git diff --cached [filename]      // mostra a video solo e soltanto i cambiamenti che sono stati messi nell'area di stage

git diff <from-branch-name>..<to-branch-name>

git diff <from-commit>..<to-commit>

git stash

git stash pop

git stash apply		// è come pop con la differenza che non viene rilasciata la memoria di stash

git stash list

git stash apply stash@{2}

git stash drop stash@{2}

git stash clear

git checkout <hash-commit>		// torno indietro nel tempo

git checkout HEAD~1				// torno indietro di 1 passo rispetto alla posizione attuale di HEAD

git switch - 					// da detached HEAD torno all'ultimo commit del branch in cui mi trovo

git checkout HEAD <file> [<file>]	<-->  git restore <file> [<file>]	// tutte le modifiche del file verranno eliminate 

git restore --source HEAD~1 <file> [<file>]

git restore --staged <file> [<file>]		// funziona nel momento in cui voglio togliere un file dalla condizione di staged (git add)

cat .git/HEAD		// mi restituisce il commit dove punto

git reset <file-name>        // metto il file-name nella situazione di staged

git reset <hash-commit>			// torno al commit indicato e tutto quello che era stato committato prima me lo trovo in fase di unstaged

git reset --hard <hash-commit>

git revert <hash-commit> 		// agginge un commit che fa l'undo dei precedenti

git clone <url>

git remote -v

git remote add <name> <url>		// aggancio un repository locale con uno creato ex-novo su GitHub

git remote rename <old> <new>

git remote remove <name>

git push <remote> <branch>		// crea su github un branch con lo stesso nome che gli abbiamo dato in locale, le volte successive aggiornerà lo stato del repository su github

git push -u <remote> <branch>	// dopo la prima volta che lo eseguiamo possiamo semplificare il comando da eseguire scrivendo soltanto "git push"

git push <remote> <local-branch>:<remote-branch>		// carica su github tutte le modifiche che sono state fatte nel branch locale su un remote branch che ha un nome diverso da quello locale...

git branch -r

git checkout <remote>/<branch>		// torno all'ultimo commit che riguarda il progetto clonato da gitHub 

git push origin main			// carico gli ultimi commit locali su gitHub

git switch <nomeBranch>				// mi permette di clonare sul mio host il branch remoto di gitHub (che ha lo stesso nome)

git fetch <remote>				// il comando fetch mi permette di aggiornare l'origin SENZA andare a modificare il mio workspace

git fetch <remote> <branch>		// seleziono soltanto un branch di mio interesse

git pull <remote> <branch>		// posso anche scrivere soltanto "git pull", "git pull" = "git fetch" + "git merge"